# Chapter 11 for 반목문
---

`chapter 11`에서는 Go 언어에서 for 반목문을 통해 어떤식으로 같은 행동을 반복할 수 있는지에 대해서 설명한다.

1. **for 문의 동작 원리**
2. **for 문의 활용 형태**
3. **break와 continue**
4. **중첩 for문**
    
    ---
    

## for 문의 동작 원리 

- 프로그램에서 반복되는 동작에 대한 코드를 간결하게 작성하고, 재사용성을 높이기 위해, 반복문을 사용한다. 다른 언어에서 `for`, `while`, `do-while` 등 여러 형태의 반복문을 지원하지만, Go언어 에서는 **for 반복문 하나를 여러가지 형태로 제공한다.**
- 기본 형태는 아래와 같다.
    
```go
 for 초기문; 조건문; 후처리 {
   코드 블록
 }
```
    
1. 제일 먼저 `for` 문이 실행되면, `초기문`부터 실행된다.
2. 그 후 `조건문`을 검사하여 만약 `조건문`이 `true`를 반환한다면, 내부의 `코드 블록`을 실행한다. 그리고 만약 `false`를 반환한다면, 반복문의 수행을 종료한다.
3. 내부의 `코드 블록`를 실행한 뒤 `후처리`를 실행하고, **2번**으로 넘어간다.


---

## for 문의 활용 형태 

- 앞에서 언급했다 시피, Go언어에서는 for 문을 여러 형태로 제공한다. 이를 적재적소 잘 사용해서 가독성과 효율을 동시에 챙길 수 있다.

### 초기문 생략 
- `초기문`을 생략한 형태의 for 문을 사용할 수 있다.
  - 다만, `;`를 생략해서는 안된다. 이는 `조건문`의 위치를 컴파일러에게 알려주기 위함이다. 
```go
 for ; 조건문; 후처리 {
   코드 블록
 }
```
### 후처리 생략
- `후처리`를 생략한 형태의 for 문을 사용할 수 있다.
  - 이때에도, 조건문 뒤 `;`를 생략해서는 안된다. 
```go
 for 초기문; 조건문; {
   코드 블록
 }
```
### 조건문만 있는 경우
- 조건문만 있는 경우는 다른 언어에서의 `while`문과 유사한 형태로 `;`과 `조건문`만을 통해 `코드 블록`을 반복 수행할 수 있다.
```go
 for ; 조건문; {
   코드 블록
 }
```
<br>

- 아래와 같이 더욱 `while`문 처럼 활용할 수 있도록 `;`를 생략해도 좋다.
 ```go
 for 조건문 {
   코드 블록
 }
 ```


### 모두 생략(무한루프)
- 무한 반복문이다. 이는 조건문이 `true`가 된 형태로, 내부의 `코드 블록`을 무한히 반복한다.
  - 중간에 멈춰주는 로직이 없다면, 런타인의 콜스택이 ~~터져~~넘쳐 버려 곤란한 상황이 연출되니,, 주의해서 사용해야한다.
  
```go
 for true {
   코드 블록
 }
```
<br>
- 아래와 같이 `true` 생략해도 좋다.

```go
 for {
   코드 블록
 }
```
    
---

## break와 continue

- 우리는 반복문을 제어하는 수단이 필요하다. 가령 무한 루프에서 빠져나오거나, 특정 순간에 다음 반복을 수행하고 싶은 경우다. 다른 언어와 정말 똑같이 `break`와 `continue` 키워드를 제공한다.
- 보통, `if`문과 같은 흐름제어문과 함께 사용된다.

1. `break`: `코드 블록`을 수행하다가 `break`를 만나면 곧 바로 해당 for 반복문의 수행을 중단하고, 빠져나온다.
2. `continue`: `코드 블록`을 수행하다가 `continue`를 만나면 곧 바로 `후처리`를 수행하고, 다시 `조건문` 검사를 통해 계속해서 반복문을 수행한다. 

---

## 중첩 for문

- 중첩 `if`문과 마찬가지로, 반복문 안에 또 다른 로직을 수행하는 다른 반목문을 추가하고 싶을 때, 중첩해서 for 문을 수행할 수 있다.
- 아래와 같이 여러 개의 반복문을 중첩하여 사용할 수 있다.
```go
package main

import "fmt"

func main() {
    for i := 0; i < 3; i++ {
        for j := 0; j < 5; j++ {
            fmt.Print("*")
        }
        fmt.Println()
    }
}

```

- 하지만, 알고리즘 공부를 조금만 해보아도, 저어어엉마아알 필요한 경우가 아니라면, 중첩 반복문의 사용은 신중히 해야한다는 것을 알 것이다. 반복문이 중첩이 될수록 프로그램의 시간복잡도는 기하급수적으로 크게 증가하기 때문이다.
    - 또한, 코드의 가독성에 악영향을 미치는 요인 중 하나가 된다.
### label
- 우리는 이러한 중첩 반복문에 대한 제어를 손쉽게 하기위해 위에서 언급한 `break`와 `continue`를 적절히 사용할 수 있다.
- 내부의 for 문에서 완전히 모든 for 문을 빠져나가고 싶은 순간에는 원래 같으면 `flag`용 변수를 만들어서 해당 변수와 `if 문`을 통해 다시 외부의 for 문을 빠져나와야 한다.
- 하지만, `flag` 용 변수를 새로이 선언하고, 여러 for 문을 빠져나오고 싶다면, 미리 for 문에 `label`을 정해 놓고, 해당 `label`에 대하여 `break`를 수행해주면 된다.
- 아래와 같이 `OuterFor`에 대하여 `break`를 수행해주면, `label`에 최상위 for문까지 수행을 종료할 수 있다.

```go
package main

import "fmt"

func main() {
	a := 1
	b := 1

OuterFor:
	for ; a <= 9; a++ {
		for b = 1; b <= 9; b++ {
			if a*b == 45 {
				break OuterFor
			}
		}
	}

	fmt.Printf("%d * %d = %d\n", a, b, a*b)
}

```
> 하지만, `label`을 사용하는 것은 혼동을 유발하고, 흐름제어에 대한 예기치 못한 오류를 야기하기 때문에, 되도록이면 중첩 반복문, **그리고 label을 이용한 흐름제어는 최대한 지양하는 것이 좋다.**
> **차라리 내부 로직을 함수로 분리하여 활용하는 것이 유지보수 및 가독성에 좋은 방법이다.**

---
Go 언어에서는 반복문은 for 문만을 여러 형태로 지원한다. 이를 직접 한번씩 연습해보며 익숙해지는 것이 중요하다.
