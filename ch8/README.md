# Chapter 8 상수
***
`chapter 8`에서는 Go 언어에서 상수를 활용하는지에 대해서 설명한다.
1. **상수의 정의**
2. **상수 선언법**
3. **상수 사용법**
4. **열거값 사용법**
***

## 상수의 정의
* `상수`는 기본적으로 변하지 않는 값을 표현할 때 사용된다. `(항)상 (같은)수`라고 이해하면 편하다.
    * `변수`는 프로그램 런타임 시, 수시로 `변(경 될 수 있는)수`라고 생각하자
    * 컴파일 시, `상수`를 변경하고자 하면, 에러가 발생한다.
* `상수`의 **불변성**을 통해 프로그래머는 자주 사용되지만 절대로 변경되지 않는 숫자값 혹은 문자열 값을 상수로 지정하여 사용한다.
* `상수`는 컴파일 시, `리터럴`로 치환되어 프로세스 메모리 구조의 Text 영역의 실행 파일 코드 속에 저장된다. 그렇기 때문에, 메모리 주소를 출력할 수 없다.
    * 그렇기 때문에, 컴파일 타임에서 값이 치환되어 변환되기 때문에, 상수 표현식 계산에서는 런타임 시, CPU 자원을 사용하지 않느다.

***

## 상수의 선언법

* 상수는 초기화 이후에는 값을 절대로 변경할 수 없다. 상수의 선언은 아래와 같이 `const` 키워드를 통해 선언한다.
```go
  const ConstValue1 int = 10
  const ConstValue2 = "CONSTANT_VALUE"
```
* 상수는 원시 타입의 값들로만 선언할 수 있다.
    * 숫자: `int`, `float` `complex(복소수)`
    * 논리값: `boolean`
    * 문자열: `rune`, `string`
        * `rune`은 유니코드(UTF-8)를 제어하기 위한 타입으로 Go언어 에서는 `int32` 타입을 재정의하여 사용하고 있다. 자세한건 [docs](https://pkg.go.dev/builtin#rune)를 확인해보자.
* `ConstValue2`와 같이 타입이 명시되지 않은 `상수`는 변수에 대입되거나, 연산, 함수 호출과 같이 변수에 복사될 때, 적절한 타입으로 정해진다.
    * 이를 이용하여, 여러 곳에서 사용되는 `상수`의 경우에는 타입을 명시하지 않는 것이 편리한다.
* 상수의 네이밍 룰은 변수와 같다. 첫글자가 대문자인 상수는 패키지 외부로 공개되는 상수, 소문자로 선언되면 패키지 내부에서만 사용하는 상수다.

***

## 상수의 사용법
상수는 1)변하는 안되는 값을 선언하고자 할 때, 2)코드 값을 통해서 값에 의미를 부여하고자 할 때, 사용한다.

### 변하면 안되는 값에 상수를 사용하자.
* 예를 들어, 원주율같은 값은 `3.141592653589793238...`로 고정된 값이다. 숫자 계산 시, 사용되는 원주율 값이 바뀌어 버리면 문제가 발생할 수 있다.
* 이러한 경우에 프로그래머는 값을 상수로 선언함으로써, 변경가능성을 원천 차단하여 안전한 프로그램을 생산할 수 있다.

### 코드 값을 통해 값에 의미를 부여할 때, 사용하자.
* 예를 들어, 우리는 `HTTP` 프로토콜에서 응답코드 `200`은 OK를 의미하는 것을 알고 있다. 이처럼 특정 숫자나 문자에 의미가 있을 때, 상수를 사용하면, 오탈자 혹은, 가독성 차원에서 안전한 프로그램을 생산할 수 있다.
  ```go
  animal:="Pig"
  ```
  * 이와 같이 특정 문자열을 통해 프로그램의 로직을 제어한다고 하면, 다른 곳에서 "Pih", "Pif" 등 과 같이 오탈자가 발생했을 때, 디버깅하거나 가독성을 저하시킬 수 있다.
      * 제일 좋은 에러는 컴파일 시 발견되는 에러다.
* 하지만, 아래와 같이 상수를 코드값으로 사용한다면, 적어도 위와 같은 에러를 만날 가능성을 대폭 줄여준다.
```go
const Pig = "Pig"

animal = Pig
```

***

## 열거 사용법
* 다른언어에서는 `Enum`을 통해서 열거 상수를 제어할 수 있다. Go에서는 `iota`키워드를 통해서 순차적으로 0부터 하나씩, 열거 상수를 제어할 수 있다.
  
* `iota`는 소괄호에 묶인 초기화 코드 블록안에서만 유효하고, 이를 벗어나면 다시 초기값으로 `iota`가 진행하던 값들의 순서가 초기화된다. **즉, 0부터 다시 시작한다.**
* 또한, 첫 줄에 한번 iota를 사용하면 같은 초기화 코드 블록 안에서, 같은 규칙을 따르는다.
 ```go
package main

import "fmt"

const (
	RED   int = iota // 0
	BLUE  int = iota // 1
	GREEN int = iota // 2
)

const (
	C1 uint = iota + 1 // 1 + 0 = 1
	C2 // 1 + 1 = 2 
	C3 // 1 + 2 = 3
)

const (
	BIG_FLAG1 uint = 1 << iota //1 << 0 = 1
	BIG_FLAG2 // 1 << 1 = 2
	BIG_FLAG3 // 1 << 2 = 4
	BIG_FLAG4 // 1 << 3 = 8
)

func main() {
	fmt.Println(RED, BLUE, GREEN)
	fmt.Println(C1, C2, C3)
	fmt.Println(BIG_FLAG1, BIG_FLAG2, BIG_FLAG3, BIG_FLAG4)
}

  ```


